# 同步and异步

- 同步⽇志是指当输出⽇志时，必须等待⽇志输出语句执⾏完毕后，才能执⾏后⾯的业务逻辑语句，⽇志输出语句与程序的业务逻辑语句将在同⼀个线程运⾏。
  每次调⽤⼀次打印⽇志API就对应⼀次系统调⽤write写⽇志⽂件.
- 异步日志是指在进行日志输出时，日志输出语句与业务逻辑语句并不是在同⼀个线程中运⾏，而是有专⻔的线程⽤于进行日志输出操作。业务线程只需要将⽇志放到⼀个内存缓冲区中不用等待即可继续执执后续业务逻辑（作为日志的生产者），
  而日志的落地操作交给单独的日志线程去完成（作为日志的消费者）, 这是⼀个典型的生产-消费模型。

# 阻塞队列

其中加入阻塞队列模块主要是解决异步写入日志做准备.

# 原理

多个生产者线程和多个消费者线程共享同一固定大小的缓冲区，它们的生产和消费符合以下规则：

- 生产者不会在缓冲区满的时候继续向缓冲区放入数据，而消费者也不会在缓冲区空的时候，消耗数据
- 当缓冲区满的时候，生产者会进入阻塞状态，当下次消费者开始消耗缓冲区的数据时，生产者才会被唤醒，开始
  往缓冲区中添加数据；当缓冲区空的时候，消费者也会进入阻塞状态，直到生产者往缓冲区中添加数据时才会被唤醒


每个宏都使用 do { ... } while(0); 结构来包裹实际的宏定义。


# 可变参数的使用
```c++
#include <cstdarg>
#include <cstdio>

void myPrintf(const char *format, ...) {
    va_list args;
    va_start(args, format); // 初始化args，从format之后的参数开始

    vprintf(format, args); // 使用vprintf来格式化并输出参数

    va_end(args); // 清理工作
}
```


# 效率
